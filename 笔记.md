# React 学习笔记

> React 起源于 Facebook，是 Facebook 开发出的一款 JS 库，Fackook 认为 MVC 无法满足他们的拓展需求

**特点**

1. React 不使用模板
2. React 不是 MVC 框架
3. 响应式
4. React 是一个轻量级的 JS 库

## 原理

- 虚拟 DOM
    React 把 DOM 抽象成一个 JS 对象，虚拟 DOM 确保只对界面上真正发生变化的部分实际 DOM 进行操作
- diff 算法
    数据更新时先更新虚拟 DOM
    1. 确保只对界面上真正发生变化的部分进行实际的 DOM 操作
    2. 逐层次的节点来进行比较

> 详细内容之后补充

## 起步

### React 开发环境搭建

1. 引入文件
    - react.js 核心文件
    - react-dom.js 渲染页面当中的 DOM，必须依赖于 react 核心文件
    - babel.js 转义 ES6 -> ES5, JSX -> JS

```bash
npm i react react-dom babel-standalone -S
```

2. 搭建一个简单的应用

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 引入依赖 -->
    <script src="./../node_modules/react/umd/react.development.js"></script>
    <script src="./../node_modules/react-dom/umd/react-dom.development.js"></script>
    <script src="./../node_modules/babel-standalone/babel.min.js"></script>
    <title>Document</title>
</head>
<body>
    <!-- 创建 DOM 根节点 -->
    <div id="app"></div>

    <script type="text/babel">
        // JSX = JS + XML
        // 优点： 执行效率快，类型安全，编译时能及时发现错误，编写模板更快捷
        let myDom = <h1>Hello World</h1>

        ReactDOM.render(myDom, document.querySelector('#app'))
    </script>
</body>
</html>
```

### JSX

JSX = JS + XML

1. 注释

```jsx
{/* 单行注释 */}
```

2. 一段 JSX 必须只有一个唯一根元素( 类似于 Vue 组件 )，最好用括号包裹起来

```jsx
let app = (<div>
    <p>一段文字</p>
    <p>两段文字</p>
</div>)

// 会报错
// let app = <p>一段文字</p><p>两段文字</p> 
```

3. 插入变量与表达式(花括号)

```js
let text = 'Hello World'

let myDom = <p>{ text }</p>

ReactDOM.render(myDom, document.querySelector('#app'))
```

4. 渲染数组

```js
let arr = [
    <li>1</li>,
    <li>2</li>,
    <li>3</li>,
    <li>4</li>
]

// 多个 li 插入到 ul 中
let myDom = <ul>{ arr }</ul>

ReactDOM.render(myDom, document.querySelector('#app'))
```

5. 属性设置

```js
let link = 'http://www.baidu.com'
let text = '百度'

let myDom = <a href={link}>{ text }</a>

ReactDOM.render(myDom, document.querySelector('#app'))
```

6. 设置 style

```js
// 必须是对象
let style = {
    color: 'red',
    backgroundColor: 'pink'
}

let myDom = <p style={style}>样式</p>
ReactDOM.render(myDom, document.querySelector('#app'))
```

7. CSS 类

**在 JSX 中不能使用 class, class 是 JS 关键字,可以使用 className**

```js
let className = 'class-name'

let myDom = <p className={className}>样式</p>
ReactDOM.render(myDom, document.querySelector('#app'))
```

8. 列表渲染

- map

```js
let arr = [1, 2, 3]

let myDom = arr.map((item, index) => {
    {/* 必须加 key 值,且每个 key 值必须是独一无二的 */}
    return (
        <p key={index}>{index + '-' + item}</p>
    )
})
ReactDOM.render(myDom, document.querySelector('#app'))
``` 

- for-in

```js
let arr = [1, 2, 3]
let newArr = []

for ( let prop in arr ) {
    newArr.push(<p key={prop}>{prop + '-' + arr[prop]}</p>)
}

let myDom = newArr
ReactDOM.render(myDom, document.querySelector('#app'))
```

9. 事件

```js
let arr = ['吃饭', '睡觉', '打豆豆']

let myDom = arr.map((item, index) => {
    return (
        {/* 事件用小驼峰形式绑定,花括号内要书写函数,如果书写 JS 语句的话他会立即执行 */}
        <p key={index} onClick={() => {console.log(item)}}>{ item }</p>
    )
})
```

10. 遍历对象

- js 对象的遍历方法

```js
let obj = {
    name: 'xiaye',
    age: 21
}

comsole.log( obj.name ) // xiaye
console.log( boj[age] ) // 21
console.log( Object.keys( obj ) ) // ['name', 'age']
console.log( Object.values( obj ) ) // ['xiaye', 21']
```

- react 对象遍历

```jsx
let info = {
    name: 'xiaye',
    age: 21
}

{/* 方法 1 */}
let app1 = Object.keys( info ).map(item => {
    return (
        <p>{ item + ':' + info[item] }</p>
    )
})

{/* 方法 2 */}
function render () {
    let arr = []
    for ( let prop in info ) {
        arr.push(
            <p>{ prop + ':' + infp[prop] }</p>
        )
    }
    return arr
}
let app2 = render()

ReactDom.render( app1, document.querySelector('#app') )
ReactDom.render( app2, document.querySelector('#app') )
```

## React 组件

### 什么是组件

1. 高耦合低内聚

- 高耦合：把逻辑紧密的内容放在同一个组件内
- 低内聚：把不同组件的依赖关系弱化，每个组件尽可能独立起来

2. 组件中的重要内容

- 构建方式
- 组件的属性
- 生命周期

3. 演变过程

传统组件的几个明显特点：**简单的封装，简单的生命周期呈现，明显的数据流动。**当一个项目比较复杂的时候，传统的组件化根本不能很好的把结构样式和行为结合，让项目难以维护，react 的组件分为 3 个部分，**属性（prop），状态（state）,生命周期**

3. react 组件

- 函数组件 / 无状态组件 与 类组件

> 组件或函数的首字母必须大写

```js
// 1.正常写法
function MyComponent () {
    return (
        <div>我是一个函数组件</div>
    )
}

let renderComponent = <MyComponent />

ReactDom.render( renderComponent, document.querySelect('#app') )

// 2.父子组件嵌套写法
function ChildrenComponentOne () {
    return (
        <div>我是子组件一</div>
    )
}

function ChildrenComponentTwo () {
    return (
        <div>我是子组件二</div>
    )
}

function PraentComponent () {
    return (
        <div>
            <ChildrenComponentOne />
            <ChildrenComponentTwo />
        </div>
    )
}

ReactDOM.render( <PraentComponent />, document.querySelector('#parent') )

// 3.类组件写法
class ClassComponent extends React.Component {
    render () {
        return (
            <div>
                <p>我是类组件</p>
                <PraentComponent />
            </div>
        )
    }
}
```

- props

> props 是 react 中的一个重要概念，是组件对外的接口，props 就可以从组件的外部向内部进行数据传递，也可以完成父子组件的数据传递，无论无状态组件还是类组件都无法修改自身的 props

```jsx
let age = 21
let date = {
    year: 2021,
    month: 6
}

// 无状态组件
function Component ( props ) {
    return (
        <div>姓名是：{ props.name }，年龄是：{ props.age }，今年是：{ props.year }年，{ props.month }月</div>
    )
}

// 设置默认值 （当这个值有的话将会被覆盖）
Component.defaultProps = {
    name: '夏叶'
}

ReactDOM.render( <Component name="夏叶" age={ age } { ...date } />, document.querySelector('#props') )

// 类组件
class ClassComponent extends React.Component {
    // 设置默认值 （当这个值有的话将会被覆盖）
    static defaultProps = {
        name: '夏叶'
    }

    render () {
        return (
            <div>姓名是：{ this.props.name }，年龄是：{ this.props.age }，今年是：{ this.props.year }年，{ this.props.month }月</div>
        )
    }
}

// 设置默认值的第二种写法 （当这个值有的话将会被覆盖）
Component.defaultProps = {
    name: '夏叶'
}

ReactDOM.render( <ClassComponent name="夏叶" age={ age } { ...date } />, document.querySelector('#props-class') )
```

- props 验证

> 验证传递过来的数据是否符合我们期望的类型或条件，生产环境请删除验证（它会在控制台报错但不会影响程序运行）

+ 安装

```bash
npm i props-type -S
```

+ 验证

```jsx
Component.propTypes = {
    // 验证 age 的类型必须是是 number
    age: PropTypes.number,
    // 验证 name 的类型必须是是 string 且不能为空
    name: PropTypes.string.isRequired
    // 更多类型的验证可以到官网查询
}
```

## state

> 如果使用 state，那么就不能使用 无状态组件 / 函数组件

### state 与 props 的区别 ?

1. props 是组件对外的接口，state 是组件对内的接口。组件内可以引用其他组件，组件之间的引用就形成了一个树状的接口，如果下层组件需要使用上层组件的数据，上层组件就可以通过下层组件中的 props 来进行数据的传递，因此 props 是组件对外的接口。组件除了使用上层组件传递的数据之外，它自身也可能有需要管理的数据，这个对内管路数据的属性就是 state。当 state 中的数据发生改变时，页面就会自动发生改变。
2. state 是可变的，而 props 对于当前组件来说只是可读的

### 使用方法

- 使用 state

```jsx
class Component extends React.Component {
    // 在 ES6 中，不管子组件写不写 constructor，在 new 实例的时候都会补上 constructor
    // 如果我们写了 constructor 就必须在其中写上 super()
    // super 就是指向父类的构造方法
    // 如果想在 constructor 中使用 props，就必须在 super 中写上 props
    constructor ( props ) {
        super( props )

        // 定义 state
        this.state = {
            name: '夏叶',
            html: '<p>一段html</p>'
        }
    }

    render () {
        return (
            // 使用 state
            <div>
                <p>我是{ this.state.name }</p>
                <div>{ this.state.html }</div>
                {/* 插入一段 html  需要使用 dangerouslySetInnerHTML={ {__html: this.state.html} } ，否则将会变成一段字符串插入*/}
                <div dangerouslySetInnerHTML={ {__html: this.state.html} }></div>
            </div>
        )
    }
}

ReactDOM.render( <Component />, document.querySelector('#app') )
```

- 修改 state

> setState 是**异步**的，当 setState 方法被调用时，react 就会自动触发 render 进行数据的渲染

```jsx
class Component extends React.Component {
    constructor ( props ) {
        super()

        // 定义 state
        this.state = {
            name: '夏叶'
        }
    }

    render () {
        return (
            <div>
                <p>我是{ this.state.name }</p>
                {/* 修改 state */}
                <button onClick={() => { this.setState({ name: '夏志朋' }) }}>把名字改成夏志朋</button>
            </div>
        )
    }
}

ReactDOM.render( <Component />, document.querySelector('#app') )
```

- 也可以是一个函数

```js
class Component extends React.Component {
    constructor ( props ) {
        super()

        // 定义 state
        this.state = {
            name: '夏叶'
        }
    }

    changeName = () => {
        // setState 中第一个参数写成函数就可以进行一些其他操作
        this.setState(() => {
            if ( name == '夏叶' ) {
                return {
                    name: '夏叶啊‘
                }
            } else {
                return {
                    name: '改成了夏叶'
                }
            }
        })
    }

    render () {
        return (
            <div>
                <p>我是{ this.state.name }</p>
                {/* 修改 state */}
                <button onClick={() => { this.setState({ name: '夏志朋' }) }}>把名字改成夏志朋</button>
            </div>
        )
    }
}

ReactDOM.render( <Component />, document.querySelector('#app') )
```

- setState 异步注意事项

```jsx
class Component extends React.Component {
    constructor ( props ) {
        super()

        this.state = {
            name: '夏叶'
        }
    }

    // 箭头函数的 this 将会指向这个类（即组件），不使用箭头函数 this 将会指向这个函数，将会无法调用 setState
    changeHandler = () => {
        this.setState({
            name: '异步'
        }, () => {
            console.log('数据更新完成')
        })
    }

    render () {
        return (
            <div>
                <p>我是{ this.state.name }</p>
                {/* 修改 state */}
                <button onClick={() => { this.setState({ name: '夏志朋' }) }}>异步操作</button>
            </div>
        )
    }
}

ReactDOM.render( <Component />, document.querySelector('#app') )
```

## refs

概念：表示当前组件真正实例的引用，他会返回绑定当前属性的元素，使用方法：

- 字符串的方法
- 回调函数（推荐）
- React.createRef() -> React 16.3 提供的一个新方式

> 不能在无状态组件中使用，因为无状态组件没有实例。官方文档中不建议我们过度使用 refs 对逻辑进行处理，需要优先考虑 state

1. 字符串方法

```jsx
<div id="app"></div>

<script type="text/babel">
    class Component extends React.Component {
        get = () => {
            console.log(this.refs.button)
        }

        render () {
            return (
                <div>
                    {/* 1 字符串方法 */}
                    <button ref="button" onClick={this.get}>第一种方法</button>
                </div>
            )
        }
    }

    ReactDOM.render( <Component />, document.querySelector('#app') )
</script>
```

2. 回调函数方法

> Dom 节点上或者组件上挂载函数，函数的形参，就是 Dom 节点，他的效果和字符串方法是一样的，都是获取值的引用

```jsx
<div id="app"></div>

<script type="text/babel">
    class Component extends React.Component {
        two = () => {
            console.log(this.input.value)
        }
        render () {
            return (
                <div>
                    {/* 2 回调函数方法，会立刻执行 */}
                    <input type="text" ref={(el) => {this.input=el}} />
                    <button onClick={this.two}>第二种方法</button>
                </div>
            )
        }
    }

    ReactDOM.render( <Component />, document.querySelector('#app') )
</script>
```

3. React.createRef()

> 把值赋给一个变量，通过 ref 挂载在节点或者组件上，使用 ref 的 current 属性拿到这个节点

```jsx
<div id="app"></div>

<script type="text/babel">
    class Component extends React.Component {
        constructor (props) {
            super(props)
            this.refDom = React.createRef()
        }

        three = () => {
            console.log(this.refDom.current)
        }

        render () {
            return (
                <div>
                    {/* . React.createRef() */}
                    <button ref={this.refDom} onClick={this.three}>第三种方法</button>
                </div>
            )
        }
    }

    ReactDOM.render( <Component />, document.querySelector('#app') )
</script>
```

## react 事件处理

> react 绑定事件使用的是小驼峰命名法，在绑定函数的时候不能加 () 避免函数会立即执行

### 修改 this 指向

修改 this 指向的三种方法：
    - bind 方式绑定
    - 函数通过箭头函数进行创建
    - constructor 中提前绑定
    - 把事件的调用携程箭头函数的调用方式

1. bind 方式绑定

```jsx
<div id="app"></div>

<script type="text/babel">
    class Component extends React.Component {
        one () {
            console.log(this)
        }

        render () {
            return (
                <div>
                    <button onClick={this.one.bind(this)}>第一种方式</button>
                </div>
            )
        }
    }

    ReactDOM.render( <Component />, document.querySelector('#app') )
</script>
```

2. 函数通过箭头函数进行创建

```jsx
<div id="app"></div>

<script type="text/babel">
    class Component extends React.Component {
        two = () => {
            console.log(this)
        }


        render () {
            return (
                <div>
                    <button onClick={this.two}>第二种方式</button>
                </div>
            )
        }
    }

    ReactDOM.render( <Component />, document.querySelector('#app') )
</script>
```

3. constructor 中提前绑定

```jsx
<div id="app"></div>

<script type="text/babel">
    class Component extends React.Component {
        constructor ( props ) {
            super( props )
            this.three = this.three.bind(this)
        }

        three () {
            console.log(this)
        }


        render () {
            return (
                <div>
                    <button onClick={this.three}>第三种方式</button>
                </div>
            )
        }
    }

    ReactDOM.render( <Component />, document.querySelector('#app') )
</script>
```

4. 把事件的调用携程箭头函数的调用方式

```jsx
<div id="app"></div>

<script type="text/babel">
    class Component extends React.Component {
        four () {
            console.log(this)
        }


        render () {
            return (
                <div>
                    <button onClick={() => { this.four() }}>第四种方式</button>
                </div>
            )
        }
    }

    ReactDOM.render( <Component />, document.querySelector('#app') )
</script>
```

### 事件对象

> 事件对象不是原生事件，是合成事件对象

```js
// React 的合成事件对象
class Event {
    // ...
}

const event = new Event()
```

1. 打印输出的事件对象的参数都是 null，可以使用吗

- 可以，虽然在打印输出的事件对象是 null， 但是具体打印某个值时会有内容

### 事件参数

> 箭头函数可以通过在 React 上绑定事件中使用箭头函数触发函数来传递参数，非花箭头函数可以使用 bind 方法传递参数

```js
class EventParams ectends Component {
    params = num => {
        alert('num')
    }

    paramsTow (num) {
        alert(num)
    }

    render () {
        return (
            <div>
                <button onClick={() => { this.params(123) }}></button>
                <button onClick={() => { this.paramsTwo.bind( this, 123 ) }}></button>
            </div>
        )
    }
}
```

### 处理表单

```js
class Form extends Conponent {
    constructor () {
        super()

        this.state = {
            username: '',
            password: ''
        }
    }

    changeUsername = e => {
        this.setState({
            username: e.target.value
        })
    }

    changePassword = e => {
        this.setState({
            password: e.target.value
        })
    }

    submit = () => {
        console.log(this.state)
    }

    render () {
        const { username, password } = this.state

        return (
            <div>
                <input value={ username } onChange={ this.changeUsername } placeholder="请输入用户名" />
                <input value={ password } onChange={ this.changePassword } placeholder="密码" />
                <input defaultValue="123" />
                <button onClick={ this.submit }>提交</button>
            </div>
        )
    }
}
```

什么是受控组件？[ 面试 100% ]

- 父组件控制子组件(React 元素)，这个子组件就是受控组件
- 受控组件解决的是表单元素绑定 value 之后无法输入的问题

如何解决表单元素无法输入的问题？ [ 面试 100% ]

- 受控组件
- 使用 defaultValue 属性

父组件只能/必须用 state 老控制子组件吗

- 不一定，也可以用 e.target 或其他方式

## 条件渲染

> 根据状态的变化只渲染其中的一部分

1. if 语句

**jxs 中不允许有 if**

```jsx
class Component extends React.Component {
    constructor ( props ) {
        super( props )
        this.setState = {
            one: true
        }
    }

    render () {
        let text = this.state.one ? '你好' : '你坏'
        return (
            <div>
                {text}
                { this.state.one ? '你好' : '你坏' }
                { this.state.one ? <p>你好</p> : <p>你坏</p> }
                { this.state.one && <p>你好</p> }
            </div>
        )
    }
}
```

## 状态提升

> 多个组件需要反应相同的数据变化时，提升到他们最近的一个父组件中。多个组件需要利用到对方状态的情况下，那么这时候需要使用到状态提升

```jsx
<div id="app"></div>

<script type="text/babel">
    class ComponentOne extends React.Component {
        constructor ( props ) {
            super( props )
        }

        render () {
            return (
                <div>
                    <p>组件一--父组件的值：{ this.props.father }</p>    
                </div>
            )
        }
    }

    class ComponentTwo extends React.Component {
        constructor ( props ) {
            super( props )
        }

        render () {
            return (
                <div>
                    <p>组件二--父组件的值：{ this.props.father }</p>    
                </div>
            )
        }
    }

    class ParentComponent extends React.Component {
        constructor ( props ) {
            super( props )
            this.state = {
                name: 'father'
            }
        }

        changeName = () => {
            this.setState({
                name: 'Parent'
            })
        }

        render () {
            return (
                <div>
                    <p>父组件</p>  
                    <button onClick={ this.changeName }>父组件改名</button>  
                    <ComponentOne father={ this.state.name } />
                    <ComponentTwo father={ this.state.name } />
                </div>
            )
        }
    }

    ReactDOM.render( <ParentComponent />, document.querySelector('#app') )
</script>
```

## 组件通信

1. 组件通信的几种方式

- 父子组件通信
- 子父组件通信
- 非父子组件通信
- 跨组件通信
- 多组件状态共享
- 路由传递参数

2. 父子组件通信

- Father.js

```js
import Son from './son'

class Father extends Component {
    constructor () {
        super()

        this.state = {
            money: 1000
        }
    }

    render () {
        const { money } = this.state

        return (
            <div>
                <Son money={ money } />
            </div>
        )
    }
}
```

- Son.js

```js
class Son extends Conponen {
    constructor () {
        super()
        console.log( this.props.money )
    }
}
```

3. 子父组件通信

- Father

```js
import Son from './son'

class Father extends Component {
    constructor () {
        super()

        this.state = {
            money: 1000
        }
    }

    changeMoney = num => {
        this.setState({
            money: this.state.money = num
        })
    }

    render () {
        const { money } = this.state

        return (
            <div>
                <Son changeMoney={ changeMoney } />
            </div>
        )
    }
}
```

- Son.js

```js
class Son extends Conponen {
    constructor () {
        super()
    }

    changeFatherMoney = () => {
        this.props.changeMoney( 123 )
    }

    render () {
        return (
            <button onClick={ changeFatherMoney }>修改父组件的moeny</button>
        )
    }
}
```

4. 非子父组件通信

在父组件中使用 ref 获取到被通信组件的某个方法，并写在函数中并传递给触发通信的组件，触发通信的组件触发这个事件就可以将数据传输给接收参数的组件

5. 跨组件通信

> 可以使用 pubsub-js 也可以使用 React 提供的 contect api 来实现，pubsub-js 下面由提到这里就不展示了，这里只写 context api 的实现方法

- context.js

```js
import React from 'react'

// 创建一个上下文
const context = new React.createContext()

export default context
```

- Big.js

```js
import OtherComponent from './OtherComponent'
import context from './context/

class Big extends Component {
    constructor () {
        super()

        this.state = {
            name: 'xiaye'
        }
    }

    render () {
        // 使用 context.Provider 将组件包裹起来，value 是需要传递给其他组件的参数
        <context.Provider value={ this.state.name }>
            <OtherComponent />
        </context.Provider>
    }
}
```

- Small.js

```js
// Small.js 在 Big.js 中 OtherComponent 组件下的任何地方都可以
import context from './context'

class Small extends Component {
    // 使用 static contextType 来接收 context，并将他的 value 赋值给 this.context
    static contextType = context

    render () {
        return (
            <div>{ this.context }</div>
        )
    }
}
```

## 脚手架

> create-react-app 是 Facebook 官方提供的 react 脚手架

1. 全局安装脚手架环境

```bash
npm install -g create-react-app
```

2. 创建项目

**项目名不能包含中文**

```bash
create-react-app 项目名
```

3. 启动项目

```bash
npm start
```

4. 目录结构

- public    -> 静态资源目录
- src       -> 代码文件夹
    - components    -> 组件文件夹（自己创建的）
- App.js    -> 根组件
- index.js  -> 入口文件

### 组件写法

> js 组件与 jsx 组件写法相同

```jsx
import React, { Component, Fragment } from 'react'

export default class One extends Component {
    render () {
        return (
            // 不想生成多一个标签，但是又想写两个标签时可用空标签 <></> 或者 Fragment 包裹
            <>
                <div>组件第一行</div>
                <div>组件第二行</div>
            </>
        )
    }
}
```

### 图片引用

```jsx
import React, { Component, Fragment } from 'react'

import Img from './../assets/img/logo192.png'

export default class ImgComponent extends Component {
    render () {
        return (
            // 不想生成多一个标签，但是又想写两个标签时可用空标签 <></> 或者 Fragment 包裹
            <Fragment>
                {/* 在 public 目录下 */}
                <img src="logo192.png" alt="img" />

                {/* 在 assets 目录下 */}
                <img src={Img} alt="img" />

                {/* 这种方法貌似无法显示 */}
                <img src={require("./../assets/img/logo192.png")} alt="img" />
            </Fragment>
        )
    }
}
```

### 组件逆向传值

- 子组件

```jsx
import React, { Component, Fragment } from 'react'

export default class ChildrenComponent extends Component {
    render () {
        constructor ( props ) {
            super( props )
            this.state = {
                name: 'children'
            }
        }

        return (
            <div onClick={ this.props.changeName.bind( this, this.state.name ) }>点击修改父组件名称</div>
        )
    }
}
```

- 父组件

```jsx
import React, { Component, Fragment } from 'react'
import ChildrenComponent from './component/ChildrenComponent'

export default class PraentComponent extends Component {
    render () {
        constructor ( props ) {
            super( props )
            this.state = {
                name: 'parent'
            }
        }

        changeName = ( name ) => {
            this.setState({
                name
            })
        }

        return (
            <div>
                <p>父组件名称：{ this.state.name }</p>
                <ChildrenComponent changeName={ this.changeName }/>
            </div>
        )
    }
}
```

### 同级组件传值

> 需要下载组件 pubsub.js，`npm i pubsub-js -S`，使用方式是抛出与接收事件

- 抛出事件：

```js
    PubSub.publish('event', balue)
```
- 接收事件：

```js
    PubSub.subscribe('event', (msg, data) => {
        // msg  -> 抛出的事件名称
        // data -> 接收的数据
        console.log(msg, data)
    })
```

- 兄弟组件一

```js
import React, { Component, Fragment } from 'react'
import PubSub from 'pubsub-js'

export default class ChildrenComponent extends Component {
    constructor ( props ) {
        super( props )
        this.state = {
            name: 'children'
        }
    }

    pubsub () {
        PubSub.publish('changeName', this.state.name)
    }

    render () {
        return (
            <div>
                <button onClick={ this.pubsub.bind( this ) }>点击修改兄弟件名称</button>
            </div>
        )
    }
}
```

- 兄弟组件二

```js
import React, { Component, Fragment } from 'react'
import PubSub from 'pubsub-js'

export default class BrotherComponent extends Component {
    constructor ( props ) {
        super( props )
        this.state = {
            name: 'brother'
        }

        PubSub.subscribe('changeName', (msg, data) => {
            console.log(msg, data)
        })
    }

    render () {
        return (
            <div>
                <p>兄弟组件的名字：{ this.state.name }</p>    
            </div>
        )
    }
}
```

### 数据请求

- json-server：模拟数据 

1. 安装：`npm i json-server -g`
2. 使用：在根目录创建文件夹 mock，写一个 json 文件，cd 到这个文件夹内运行 `json-server json文件名 --port xxx`
3. 请求：localhost:port 即可访问到这个 json 文件，localhost:port/arr 可访问到数据中的某项

- axios：数据请求 `npm i axios -S`

1. 正向代理解决跨域：在 node_modules 文件夹内找到 react-script/config/webpackDevServer.config.js，将 proxy 参数修改为以下内容，修改完配置之后需要重启项目

```js
proxy: {
    '/api': {
        target: '',         // 代理跨域的目标请求地址，中国天气网（http://www.weather.com.cn/data/cityinfo/101320101.html）
        changeOrigin: true, // 改变源
        'pathRewrite': {
            '^/api': '/'    // 将匹配的请求路径中的 /api 替换为 /
        }
    }
}
```

## 路由

> 根据 URL 不同来切换不同的组件来实现 SPA（Single Page Application），在切换路由时页面不会刷新，更接近原生体验

### 安装 v5 版本

```bash
npm i react-router-dom -S
```

直接运行 `npm i react-router -S` 会安装路由的核心 api，功能比较少

1. v3 和 v4 及以上版本的区别

- v3 版本使用的是传统路由模式：路由表模式( 类似于 Vue 的路由表 )
- v4 及以上版本使用的是最新的路由模式：路由也是一个组件

2. 前端路由底层

- `#/home` 是哈希路由模式，原理是使用了 onhashchange 事件，兼容性最好，几乎所有浏览器都能使用
- `/home` 是 history 模式，需要后端配合，他是通过 H5 的 history api 实现的，通过 popstate 来监听 url 的变化

### 路由模式

- hash 模式：利用地址后面的 hash 值来实现（带 #，刷新的时候页面不会丢失）

1. index.js

```js
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

// 1.引入 HashRouter
import { HashRouter } from 'react-router-dom'

ReactDOM.render(
  <React.StrictMode>
    {/* 2.用 HashRouter 把 APP 包裹起来 */}
    <HashRouter>
     <App />
    </HashRouter>
  </React.StrictMode>,
  document.getElementById('root')
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();
```

2. App.js

```js
// App.js
import logo from './logo.svg';
import './App.css';

// 1.引入路由组件与页面组件
import { Route } from 'react-router-dom'
import One from './components/One'

function App() {
  return (
    <div className="App">
      <header className="App-header">
        <img src={logo} className="App-logo" alt="logo" />
        {/* 2.使用路由 */}
        <Route path="/one" component={ One } />
      </header>
    </div>
  );
}

export default App;
```

3. 访问地址：http://lcoalhost:3000/#/FirstPage


- browser 模式：历史记录模式，没有 #，通过历史记录 API 实现路由切换，刷新之后会丢失，本地模式不会丢失

1. index.js

```js
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

// 1.引入 BrowserRouter
import { BrowserRouter } from 'react-router-dom'

ReactDOM.render(
  <React.StrictMode>
    {/* 2.用 BrowserRouter 把 APP 包裹起来 */}
    <BrowserRouter>
     <App />
    </BrowserRouter>
  </React.StrictMode>,
  document.getElementById('root')
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();
```

2. App.js

```js
// App.js
import logo from './logo.svg';
import './App.css';

// 1.引入路由组件与页面组件
import { Route } from 'react-router-dom'
import One from './components/One'

function App() {
  return (
    <div className="App">
      <header className="App-header">
        <img src={logo} className="App-logo" alt="logo" />
        {/* 2.使用路由 */}
        <Route path="/one" component={ One } />
      </header>
    </div>
  );
}

export default App;
```

> 路由组件应该直接包裹 App 组件，中间不能包裹其他东西

3. 访问地址：http://lcoalhost:3000/FirstPage

### 二级路由

只需要在二级路由页面里写路由组件即可

```js
import React, { Component } from 'react'
import Nav from './nav'
import { Route } from 'react-router-dom'
import Hot from './hot'
import Comming from './comming'

export default class Home extends Component {
    render() {
        return (
            <div>
                <Nav />
                <Route path="/home/hot" component={ Hot } />
                <Route path="/home/comming" component={ Comming } />
            </div>
        )
    }
}
```

### 路由导航

> 通过 Link 组件实现，Link / NavLink 中的 to 属性表时切换到的路由地址，NavLink 在当前页面路由与 to 前往路由相同的情况下，标签会添加上 class="active"，或者通过 activeClassName 来改变激活时的类名

```js
// FirstPage
import React, { Component } from 'react'
import { Link } from 'react-router-dom'

export default class One extends Component {
    constructor (props) {
        super(props)
    }

    render () {
        return (
            <div>First Page<Link to="/SecondPage">点击前往 Second Page</Link></div>
        )
    }
}
```

Link vs NavLink

- NavLink 有激活状态，Link 没有，根据使用情景选择

### 封装路由组件

1. 在 src 目录下创建 router/index.js
2. 书写 router/index.js

```js
// 这里是路由配置文件
import {
    Redirect,
    Switch,
    Route,
} from 'react-router-dom'

// Redirect 是重定向组件
// 属性：
//      from: 从哪儿来
//      to: 到哪儿去
//      exact: 完全( 严格 )匹配，例如 / 和 /home 的匹配

// Switch 一次渲染一个组件，当两个路由组件是同一个 path 时只渲染一个，是一个优化方案
// 在 React 开发工具中可以看到渲染路由时每个路由都会会出现很多个相同的路由组件，switch 包裹下将只会渲染一个

// Route 是路由容器
// 属性：
//      path: 路由路径
//      component: 路由路径对应的组件
//      render: 渲染一个组件
//      children: 渲染一个子组件

import Home from 'Pages/home'
import Mine from 'Pages/mine'
import NotFund from 'Pages/notfund'

// 动态引入组件，即懒加载
// const OtherComponent = React.lazy(() => import('./OtherComponent'));

const RouterComponent = () => (
    <Switch>
        {/* 重定向 */}
        <Redirect from="/" to="/home" exact></Redirect>

        {/* 页面组件 */}
        <Route path="/home" component={ Home } />
        <Route path="/mine" component={ Mine } />

        {/* 错误路由匹配 */}
        <Route component={ NotFund } />
    </Switch>
)

export default RouterComponent
```

3. 在需要路由的地方引入

```js
import React, { Component } from 'react'
import RouterComponent from './router/index.js'

class Layout extends Component {
    render () {
        return (
            <RouterComponent />
        )
    }
}
```

4. component vs render vs children ?

- component 会让我们的组件拥有路由属性：`location` `match` `history`
- render 只是渲染一个组件，没有任何路由属性但可以传递属性，写法 `<Route path="/home" render={() => <Home name="xiaye" />} />`
- children 同时可以传递数据，也可以拥有路由属性，写法 `<Route path="/home" children={props => <Home name="xiaye" {...props} />} />`
- 一般情况下不需要再路由组件这里传递参数，用 component 即可

### 路由常见问题

1. 匹配 '/' 问题

> 当路由组件写法为 `<Route path="/" component={ One } />` 时会直接显示 One 组件，可以在 Route 组件加上 exact 属性 `<Route path="/" exact component={ One } />` 严格匹配不显示 One 组件，不加 exact 也可以作为两个公用部分显示

2. 重复渲染一个组件问题

> 当一个组件中出现两个相同路径的路由组件，那么会将两个组件都渲染出来，可以通过 Switch 组件来解决

```js
// App.js
import logo from './logo.svg';
import './App.css';

// 1.引入路由组件与页面组件
import { Route, Switch } from 'react-router-dom'
import One from './components/One'

function App() {
  return (
    <div className="App">
        {/* 由 Switch 组件包裹的路由两个路由路径相同只会显示一个路由组件 */}
        <Switch>
            <Route path="/one" component={ One } />
            <Route path="/one" component={ One } />
        </Switch>
    </div>
  );
}

export default App;
```

3. 路由重定向

> 使用 Redirect 模块对路由进行重定向，注意要使用 exact 进行严格匹配

```js
import logo from './logo.svg';
import './App.css';

// 1.引入路由组件与页面组件
import { Route, Redirect } from 'react-router-dom'
import One from './components/One'

function App() {
  return (
    <div className="App">
        <Redirect from="/" to="/one" exact />
        <Route path="/one" component={ One } />
    </div>
  );
}

export default App;
```

### withRouter

> withRouter 是一个高阶组件，它可以让不是路由切换的组件也具有路由操作的三个属性 `location` `match` `history`，然后通过 App 组件的 props 属性往下传递到想使用路由属性的组件上

```js
import logo from './logo.svg';
import './App.css';

import One from './components/One'
import Two from './components/Two'
import ImgComponent from './components/Img'
import Parent from './components/Parent'

import { Route } from 'react-router-dom'
import FirstPage from './pages/FirstPage'
import SecondPage from './pages/SecondPage'

// 引入 withRouter
import { withRouter } from 'react-router-dom'

function App(props) {
  // 打印属性
  console.log(props)
  return (
    <div className="App">
      <header className="App-header">
        <img src={logo} className="App-logo" alt="logo" />
        {/* 向下传递这三个属性 */}
        <One { ...props } />
        <Two />
        <ImgComponent />
        <Parent />
      </header>
      <Route path="/FirstPage" component={ FirstPage } />
      <Route path="/SecondPage" component={ SecondPage } />
    </div>
  );
}

// 用 withRouter 包裹 APP 组件
export default withRouter(App);
```

1. 监控路由变化

```js
history.listen(link => { 
    console.log(link.pathname)
})
```

2. 编程式导航

- 使用

```jsx
<button onClick={() => {props.history.push('/FirstPage')}}></button>

// replace 不会将跳转操作记录下来，做返回时不会跳回，replace 效果上返回两层
<button onClick={() => {props.history.replace('/FirstPage')}}></button>
```

- replace 使用场景

当用户未登录时进入个人中心跳转到登录界面，登陆成功之后跳转用 replace，用户点返回时候不会返回登录页面

3. 路由传参


#### 方法一：params 方式

**步骤**
- 需要在路由规则中设置传递的接收参数
- 发送参数直接在跳转路径后编写
- 接收 `props.match.params.参数名`

**优劣**
- 优势：刷新地址参数依然存在
- 缺点：只能传递字符穿，并且参数过多的时候 URL 会变得比较丑陋

```jsx
{/* 发送 */}
<NavLink to="/FirstPage/123">跳转</NavLink>

{/* 路由传参配置 */}
<Route path="/FirstPage/:id" component={ FirstPage } />
```

```jsx
{/* 接收 */}
import React, { Component, Fragment } from 'react'

export default class One extends Component {
    constructor (props) {
        super(props)
        console.log(this.props.metch.params.id)
    }

    render () {
        return (
            <>
                <div>FirstPage</div>
            </>
        )
    }
}
```

#### 方法二：query 方式

**步骤**

- 不在需要路由规则中传递参数的配置
- 直接发送数据
- 使用 `this.props.loaction.query.参数名` 接收

```jsx
{/* 发送 */}
<NavLink to={{
    pathname: '/SecondPage',
    query: {
        id: 123
    }
}}>跳转<N/avLink>

<NavLink to={{
    pathname: '/SecondPage',
    query: {
        id: 123
    },
    search: '?id=123',
    // state 可以做数据预载
    state: {
        id: 123
    },
    hash: '#234'
}}>跳转<N/avLink>
```

```jsx
{/* 接收 */}
import React, { Component, Fragment } from 'react'

export default class One extends Component {
    constructor (props) {
        super(props)
        console.log(this.props.location.query.id)
    }

    render () {
        return (
            <>
                <div>FirstPage</div>
            </>
        )
    }
}
```

> 注意：不能使用 `http://localhost/SecondPage?id=123` 来传参

## Hook

> react v16.77 新增的特性，让无状态组件也能使用类组件的特性，在 react 开发中状态管理是必不可少的，以前使用状态管理需要使用类组件或者 redux 等来管理

1. React Hook 的作用

- 解决组件之间复用状态逻辑很难
- 解决复杂组件变得难以理解
- 解决难以理解的 class

2. React Hook 有哪些

- 基础 Hook
    - useState：返回一个 state 以及更新 state 的函数
    - useEffect：该 Hook 接收一个包含命令式、且可能有副作用代码的函数
    - useContext：接收一个 context 对象( React.createContext 的返回值 )并返回该 context 的当前值
- 额外的 Hook
    - useReducer：useState 的替代方案，它接收一个形如 `(state, action) => newState` 的 reducer，并返回当前的 state 以及其配套的 dispatch 方法
    - useCallback：返回一个 memoized 函数
    - useMemo：返回一个 memoized 值
    - useRef：返回一个可变的 ref 对象
    - useImperativeHandler：useImperativeHandler 可以让你在使用 ref 时自定义暴露给父组件的实例值
    - useLayoutEffect：其函数前命与 useEffect 相同，但他会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新
    - useDebugValue：useDebugValue 可用于在 React 开发工具中显示自定义 hook 的标签

### 基础 Hook

1. useState 和 useEffect

useState 是来定义一个状态的，他与类组件的状态不同，函数组件的状态可以是对象也可以是基础类型数据
useState 返回的是一个数组，第一个是当前数组的状态值，第二个是对象表明用于更改状态的函数（类似于setState）

useEffect 可以让我们在函数组件中使用类似于类组件中的生命周期的功能：componentDidMount、componentDidUpdate、componentWillUnmount
useEffect 阶段已经生成了真实 DOM，可以进行 DOM 操作、第三方库实例化等

```js
import React, { useState, useEffect } from 'react'

function Component ( props ) {
    // useState
    let [value, setValue] = useState(0)

    // useEffect
    useEffect(() => {
        // 三个生命周期都会触发
        console.log('useEffect')
    })

    return (
        <div>
            {/* useState */}
            <p>数据：{ value }</p>
            <button onClick={() => {setValue(value + 1)}}>修改数据</button>
        </div>
    )
}
```
> 如果不用 useState 正常修改参数将不会触发重新渲染，值改变了但界面不会改变

***如果有多个状态怎么办？***

- 声明对象类型状态

```js
import React, { useState } from 'react'

function Component ( props ) {
    let [value, setValue] = useState({
        name: 'xiaye',
        age: 20
    })

    return (
        <div>
            <p>姓名：{ value.name }</p>
            <button onClick={() => {setValue(value.name = 夏叶'')}}>修改数据</button>
        </div>
    )
}
```

- 多次声明（推荐使用）

```js
import React, { useState } from 'react'

export default function Component ( props ) {
    let [value, setValue] = useState('夏叶')
    let [age, setAge] = useState(20)

    return (
        <div>
            <p>姓名：{ value }，年龄：{ age }</p>
            <button onClick={() => {setValue(value + 1)}}>修改数据</button>
            <button onClick={() => {setAge(age + 1)}}>修改年龄</button>
        </div>
    )
}
```

2. useContext

- context/index.js

```js
import React from 'react'

const moneyContext = React.createContext( 0 )

export default moneyContext
```

- Big.js

```js
import React, { useState } from 'react'
import OthenComp from './otherComp'
import moneyContext from './context'

const Big = props => {
    let [money, changeMoney] = useState( 2000 )

    return (
        <div>
            <moneyContext.Provider value={ money }>
                <OtherComp>
            </moneyContext.Provider>
        </div>
    )
}

export default Big
```

- Small.js

```js
import React, { useContext } from 'react'

// 引入 moneyContext
import moneyContext from './context'

const Small = props => {
    // 定义一个变量，使用这种方式得到上层组件传递下来的 money
    const money = useContext(moneyContext)

    return (
        <div>
            {/* 渲染 */}
            { money }
        </div>
    )
}

export default Small
```

3. useRef

useRef 它只能绑定在 React 元素上，如果需要绑定组件需要用 forwardRef 创建组件

- useRef

```js
import React, { useRef } from 'react'

const Comp = props => {
    // 定义一个变量来存储 ref
    const refComp = useRef(null)

    return (
        <div>
            {/* 将这个 ref 绑定到 React 元素上 */}
            <button>打印 ref 组件</button>
            <input ref={ refComp } />
        </div>
    )
}
```

- forwardRef

```js
import React, { forwardRef } from 'react'

const Comp = props => {
    // 定义一个组件来存储
    const FancyButton = forwardRef((props, ref) => (
        <button className="fancy-button" ref={ ref }>
            { props.children }
        </button>
    ))

    const ref = React。createRef()

    return (
        <div>
            <button>打印 ref 组件</button>
            <FancyButton ref={ ref }></FancyButton>
        </div>
    )
}
```

## React 状态管理

作用：实现多组件的状态共享，也是一个组件通信的方案

实现 React 状态管理的三个方案

- Flux
- Redux *
- Mobx

说明：React 状态管理是架构，以上三个 React 状态管理的方案都是和 MVC 一个级别的架构，而 Vuex 仅仅是 MVVM 中的一个插件。React 是属于上面三个架构的一部分

### Flux

React 只是一个 MVC 中的 V( 视图层 )，只管页面中的渲染，一旦有数据管理的时候，React 本身的能力就不足以支撑复杂组件结构的项目。在传统的 MVC 中，就需要用到 Model 和 Controller。Facebook 对于当时市面上的 MVC 框架不满意，于是就有了 Flux，但 Flux 并不是一个 MVC 框架，它是一种新的思想( 新的架构思想 )

1. Flux 的组成部分

- View：视图层( 用 React 的组件来代替 )
- ActionCreator：动作创造者，视图发出的消息( 如 mouseClick )
- Dispatcher：派发者，用来接收 Actions，执行回调函数
- Store：数据层，用来存放应用的状态，一旦发生改变就提醒 Views 来更新页面

2. 数据流向

Store 渲染数据给 React View，用户在 React View 上进行操作或者交互，ActionsCreator 进行数据交互处理( 与后端交互等 )，创建 actions 给 Dispatcher，Dispatcher 改变数据并通过回调函数给 Store，Store 数据修改之后给 React View 修改视图

- 组件获取到 store 中保存的数据挂载在自己的状态上
- 用户产生了操作，调用 actions 的方法
- actions 收到了用户的操作，进行一系列代码逻辑，异步操作，数据请求
- 然后 actions 会创建 action，action 带有标识性的属性
- action 调用 dispatcher 的 dispatch 方法将 action 传递给 dispatcher
- dispatcher 接收到 action 并根据标识信息判断之后，调用 store 的更改数据方法
- store 的方法被调用之后，更改状态，并触发自己的某一个事件
- store 更改状态后事件被触发，该事件的处理程序就会通知 view 去获取并渲染最新的数据

3. 使用

- 安装 flux

```bash
npm i flux -S
```

- 在 src 下创建 store/index.js

```js
// store 作用
// 1. 用于存储 state
// 2. 更新界面：store 必须有一个事件的订阅和发布能力 - nodejs 的 events 模块

const store = {
    // 状态
    state: {
        count: 0
    },

    // 获取状态
    getState () {
        return this.state
    },

    // 通过 nodejs 获取发布与订阅能力，让 store 有 emit 和 on
    ...require('events').EventEmitter.prototype
}

export default store
```

- 组件中

```js
import React, { Component } from 'react'
import store from './store'

// store 里的内容是 -> {
//     state: {},
//     getState(),
//     on,
//     emit
// }

// 引入 actions 中的 ADD 方法
import { add, decrement } from '@/actions'

class Comp extends Component {
    constructor () {
        super()

        this.state = {
            // 给当前组件做 state 初始化
            count: store.getState().count
        }
    }

    increment = () => {
        // 用户交互，里面的事件交给 flux 执行
        add()

        // 事件发布
        store.emit('updateView')
    }

    decrement = () => {
        decrement('参数')
        store.emit('updateView')
    }

    componentDidMount () {
        // 事件的订阅
        store.on('updateView', () => {
            this.setState({
                count: store.getState().count
            })
        })
    }

    render () {
        return (
            <div>
                <button onClick={ this.increment }>count + 1</button>
                <button onClick={ this.decrement }>count - 1</button>
                <p>store 中的 count 为：{ this.state.count }</p>
            </div>
        )
    }
}
```

- 在 src 目录下新建 actions/index.js

```js
// actions -> ActionCreators
// 表时动作的创建者，存放的都是方法

// 引入动作类型常量
import { ADD, DECREMENT } from './actionType'

// 引入 dispatcher
import dispatcher from '@/dispatcher'

export const add = () => {
    // 创建动作
    const action = {
        // 表时动作类型，区别用户在视图做了哪些操作
        type: ADD
    }

    // 发送动作 dispatcher
    dispatcher.dispatch( action )
}

export const decrement = value => {
    dispatcher.dispatch({
        type: DECREMENT,
        // payload 称之为负载，就是指视图层传递过来的参数
        payload: value
    })
}
```

- 在 actions 文件夹下创建 actionType.js 用于存储动作类型常量

```js
export const ADD = 'ADD'

export const DECREMENT = 'DECREMENT'
```

- 在 src 下创建 dispatcher/index.js，他是动作的执行者，用于修改数据

```js
import { Dispatcher } from 'flux'
import store from 'store'
import { ADD, DECREMENT } from '@/actions/actionType'

// 实例化构造函数获得 dispatcher 实例
const dispatcher = new Dispatcher()

// dispatcher 必须通过注册才能将新的数据存储到 store
dispatcher.register(action => {
    // 这个 action 就是 ActionCreator 中发来的动作 -> { type: 'ADD' }
    console.log( action ) 

    // 修改数据
    switch ( action.type ){
        case ADD:
            store.state.count++
            break

        case DECREMENT:
            console.log( action.payload )
            store.state.count--
            break
        
        default: 
            // ...
            break
    }
})

export default dispatcher
```

### redux

redux 是 flux 的进阶版，redux = flux + 函数式编程

> javascript 提供的一个可预测性 `(我们给一个固定的输入，那么必定可以得到一个结果)` 的状态容器，集中管理 react 中多个组件的状态。redux 是一个专门的状态管理库，在 vue 等框架中都能使用，在 react 中使用的比较多

1. 需求场景

- 某个组件的状态需要共享的时候
- 一个组件需要改变另外一个组件状态的时候
- 组件的状态需要在任何地方都可以拿到

2. 三大原则

- 单一数据源：整个 react 的状态都会被统一管理到 store
- state 是只读的：我们不能直接改变 state，而是要通过触发 redux 中的特定方法来进行修改
- 使用纯函数来执行修改操作：action 来改变 redux 中的 state

3. redux 的两种用法

- 数据不分块用法：所有数据写在一个文件
- 数据分块用法：将数据拆份成多块

> 类似于 Vuex 的 module

4. 核心组成部分

- store：数据的管理者和数据的存储者
- actionCreator：动作的创建者，发送动作给 reducers
- react components：视图组件
- reducres：数据的修改者，返回一个新的 newState 给 store，reducers 是一个纯函数

***问题：状态是可读的，但是 reducers 要修改状态？***

- 解决：拷贝[ 浅拷贝 | 深拷贝 ]，根据数据的结构选择浅拷贝或者深拷贝

#### 使用 redux 数据不分块

1. 在 src 目录下创建 store/index.js 文件

```js
import { createStore } from 'redux'

// 将 reducer 引入进来
import rootReducer from '@/reducer'

const store = createStore( rootReducer )

export default store
```

2. 在 src 目录下创建 reducer/index.js 文件

```js
// reducer 是纯函数，用来修改 state
// 规则：唯一数据源、状态是可读的不可修改

import { ADD_TODOS, DELETE_TODOS } from '@/actions/actionType'

const initState = {
    todos: [{
        id: 1,
        task: '任务一'
    }, {
        id: 2,
        task: '任务二'
    }]
}

const reducer = (state = initState, action) => {
    // state 就是只读的状态
    // action 就是 actioncreators 发来的动作

    // 将 state 拷贝一份
    // 解构是最简单的浅拷贝
    // JSON.stringify() | JSON.parse() 是最简单的深拷贝
    const newState = { ...state }

    switch ( action.type ) {
        case ADD_TODOS:
            // 对拷贝的 newState 进行操作
            newState.push({
                id: newState.todos[newState.todos.length -1].id + 1,
                task: action.payload
            })
            break

        case DELETE_TODOS:
            newState.splice(action.payload, 1)
            break

        default:
            console.log('default')
            break
    }

    // 将新的 newState 返回出去，给 store 之后 store 重新赋值
    return newState
}

export default reducer
```

3. 在 src 目录下创建 actions/actionType.js 文件

```js
export const ADD_TODOS = 'ADD_TODOS'

export const DELETE_TODOS = 'DELETE_TODOS'
```

4. 组件内

```js
import React, { Component } from 'react'

// 引入 store
import store from '@/store'

// 引入 actions
import actions from '@/actions'

class Comp extends Component {
    constructor () {
        super()

        this.state = {
            todos: store.getState().todos
        }
    }

    renderItems = () => {
        return this.state.todos.map((item, index) => (
            <li key={ item.id }>
                <p>{ item.task }</p>
                <button onClick={() => { this.del( index ) }}>删除</button>
            </li>
        ))
    }

    submit = e => {
        if ( e.keyCode == 13 ) {
            actions.add_todos( e.target.value )
        }
    }

    del = index => {
        actions.delete_todos( index )
    }

    componentDidMount () {
        // 订阅，用来更新视图
        store.subscribe(() => {
            this.setState({
                todos: store.getState().todos
            })
        })
    }

    render () {
        return (
            <div>
                <input onKeyUp={ this.submit } />
                <ul>{ this.renderItems() }</ul>
            </div>
        )
    }
}
```

5. 在 action 文件夹内创建 index.js 文件

```js
// 作用：创建动作

import { ADD_TODOS, DELETE_TODOS } from './actionType'
import store from '@/store'

const actions = {
    addTodos ( value ) {
        // 创建动作
        const action = {
            type: ADD_TODOS,
            payload: value
        }

        // 发送动作: store 来发送
        store.dispatch( action )
    },

    delete_todos ( index ) {
        store.dispatch({
            type: DELETE_TODOS,
            payload: index
        })
    }
}

export default actions
```

#### 使用 redux 数据分块

1. 安装模块 

- react-redux，它是帮助我们实现数据分块的
- redux-thunk，他是 redux 中间件，它帮助我们能在 redux 中做数据请求
- redux-saga，他是 redux-thunk 的升级版( 工作中使用 )
- redux-devtools-extension，帮助浏览器拓展插件识别( react、redux、redux-saga 都有自己的拓展插件 )

> 需要分开安装

```bash
npm i react-redux -S
npm i redux-thunk -S
npm i redux-devtools-extension -S
```

2. 在 src 目录下创建 store/index.js

```js
// applyMiddleware 用来调用执行中间件
// compose 用来调用 redux-devtools-extension
import { createStore, applyMiddleware, compose } from 'redux'

// thunk 是中间件，中间件就是有特殊功能的函数
import thunk from 'redux-thunk'

import { composeWithDevtools } from 'redux-devtools-extension'
import rootReducer from '@/reducers'

const store = createStore(rootReducer, composeWithDevtools(applyMiddleware(thunk)))

export default store
```

3. 在 src 目录下创建 reducers/index.js

```js
// 打造 rootReducer
import { combineReducers } from 'redux'

// 导入分片的数据
import homeModule from 'Pages/home/store'

const rootReducer = combineReducers({
    // 分片的数据
    homeModule
})

export default rootReducer
```

4. 在组件对应的文件夹内创建 store.js，例如 home/store.js

```js
// 分块出来的 home 的数据
import { GET_HOT_MOVIES } from '@/actions/actionType'

const initState = {
    hotMovies: null
}

const homeModule = (state = initState, action) => {
    // 数据复杂需要深复制
    const newState = JSON.parse(JSON.stringify( state ))

    switch ( action.type ) {
        case GET_HOT_MOVIES:
            newState.hotMovies = action.payload
            break

        default:
            console.log('default')
            break
    }

    return newState
}

export default homeModule
```

5. 在 src 目录下新建 actions/home.js

```js
// home 页面的 actions

import request from '@/request'
import { GET_HOT_MOVIES } from './actionType'

export const home = { 
    getHotMovies () {
        // 这里需要完成数据请求
        return async dispatch => {
            conts result = await request({
                url: '',
                methods: '',
                params: {}
            })

            // dispatch 是发送动作，由 redux-thunk 实现
            dispatch({
                type: GET_HOT_MOVIES,
                payload: result.data
            })
        }
    }
}
```

6. 在 actions 文件夹下创建 actionType.js 文件

```js
export const GET_HOT_MOVIES = 'GET_HOT_MOVIES'
```

7. 在 actions 文件夹下创建 index.js 文件

```js
import home from './home'

const actions = {
    // actions 下面必须是方法，所以需要解构出来
    ...home
}

// 也可以这样写，用函数调用的方法返回相应的 actions
// const actions = name => {
//     // 传入什么就会返回什么 actions，就不会返回所有的 actions
//     switch (name) {
//         case 'home':
//             return { ...home }
//             break
// 
//         case 'xxx':
//             return { ...xxx }
//             break
//     }
// }

export default actions
```

8. 在 src/index.js 中书写内容

```js
// 用来实现数据分块 - 创建了一个 Context 来传递 store
import { Provider } from 'react-redux' 

import store from 'store'

ReactDOM.render(
    // 用 Provider 将他们包裹起来并传入 store
    <Provider store={ store }>
        <Router>
            <App />
        </Router>
    </Provider>,
    document.querySelector('#root')
)
```

9. home 组件的子组件 Hot

```js
import React, { Component } from 'react'

// 在这里接收 store 中的 state 和 actions 中的 actions(getHotMovies)
// 如何接收？ 使用 connect 高阶组件接收
// 如何使用？ connect(fn1, fn2)(Component)
// connect 做了什么？ 
//      1. 根据我们当前组件来创建一个容器组件，让容器组件接收 store 中的数据和 actions 中的方法，然后传递给 UI 组件( 原组件 )
//      2. 更新视图
// connect 原理？ 合并分发：将 store 中的数据通过 mapStateFromProps 钟中的操作找到并分发下来( state.home )
import { connect } from 'react-redux'

import { bindActionCreators } from 'redux'
import actions from '@/actions'

class Hot extends Component {
    componentDidMount () {
        // actions 中的方法已经通过下面的函数绑定在 props 上了
        this.props.getHotMovies()
    }
}

const mapStateFromProps = state => {
    // 将 store 中的 state 以属性( props )的方式绑定在组件身上
    // 他的返回值是什么，我们组件属性身上就有什么
    return state.home
}

const mapDispacthFromProps = dispatch => {
    // 帮助我们将 actions 中的 action 发送给 reducer
    return bindActionCreators(actions, dispatch)

    // 如果通过函数返回了可以写成下面这种方式
    // return bindActionCreators(actions('home'), dispatch)
}

// 使用 connect
export default connect(mapStateFromProps, mapDispacthFromProps)(Hot)
```

### mobx

#### 使用

1. 创建 CRA 项目

```js
npx create-react-app mobx
```

2. 进入到项目文件夹，进行配置文件抽离

```js
npm run eject
```
> 注意：抽离配置文件之后需要先启动项目 `npm start`，如果遇到模块缺失等问题需要安装该模块。

3. 安装 mobx、mobx-react

- mobx 是状态管理工具
- mobx-react 是做数据分片和数据获取

```js
npm i mobx mobx-react -S
```

> 如果与 git 冲突，需要先将代码提交到暂存区 `git add.` `git commit -m 'test'`，千万不要提交 `git push`

4. 配置装饰器( ES6 )babel

```js
npm i babel-plugin-transform-decorators-legacy @babel/preset-env babel-plugin-transform-class-properties @babel/plugin-proposal-decorators -D
```

5. 配置 package.json

```json
"babel": {
    "plugins": [
        [
            "@babel/plugin-proposal-decorators",
            {
                "legacy": true
            }
        ],
        "transform-class-properties"
    ],
    "presets": [
        "react-app",
        "@babel/preset-env"
    ]
},
```

6. 在 src 目录下创建 store/index.js

```js
// 引入分片数据
import home from './home'

const store = {
    // 分片的数据
    home
}

export default store
```

7. 编辑 src 目录下的 index.js

```js
import store from '@/store'
import { Provider } from 'mobx-react'

ReactDOM.render(
    <Provider store={ store }>
        <App />
    </Provider>,
    document.querySelector('#root')
)
```

8. 在 store 目录下创建 home.js

```js
// mobx 中一个文件就是一个分片数据\
import { observable, action, computed } from 'mobx'

class Home {
    // 定义数据
    @observable
    name = 'xiaye'

    // 修改数据
    @action
    changeName = () => {
        // 修改上面定义的数据
        this.name = '夏叶'
    }

    // 只要数据发生改变就会触发 computed
    @computed
    get withEnglist () {
        return this.name + ' - xiaye'
    }
}

const home = new Home()

export default home
```

9. 编辑页面组件 Home.js

```js
import React, { Component } from 'react'

// injext: 注入，将 store 中的数据给组件
import { inject, observe } from 'mobx-react'

// 使用装饰器之后组件将会获得分片数据 - name 和计算属性 withEnglist
@inject('store')
@observe
class Home extends Component {
    render () {
        return (
            <div>
                <button onClick={ this.props.home.changeName }>改变名字</button>
                <p>store 中的数据：{ this.props.home.name }</p>
                <p>store 中的 computed 数据：{ this.props.home.withEnglist }</p>
            </div>
        )
    }
}

 export default Home
```